# C++11 を利用する

C++11を有効にするには Rcpp コード中に次の記述を追加する。

```cpp
// [[Rcpp::plugins("cpp11")]]
```

あるいは環境変数 `PKG_CXXFLAGS` の値に `"-std=c++11"` をセットする。

例えば、Rコンソールで

```r
Sys.setenv("PKG_CXXFLAGS"="-std=c++11")
```

Windows の Rtools でインストールされる gcc のバージョンがやや古いので（-std=c++11）は駄目かもしれない。その場合は下を使う。

```r
Sys.setenv("PKG_CXXFLAGS"="-std=c++0x")

```

###C++11を使ったのコード例

例：イニシャライザリストによる初期化

```cpp
//次の２つは同義である。
NumericVector v1 = {1,2,3,4,5};
NumericVector v2 = NumericVector::create(1,2,3,4,5};

```

例：ラムダ式

```cpp
using namespace Rcpp;

// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::export]]
std::vector<double> transformEx(const std::vector<double>& x) {
    std::vector<double> y(x.size());
    std::transform(x.begin(), x.end(), y.begin(), [](double x) { return x*x; } );
    return y;
}
```


例：乱数生成器

```cpp
#include <Rcpp.h>
#include <random>

using namespace Rcpp;

// [[Rcpp::export]]
NumericVector cxx11Normals(int n) {
    std::mt19937 engine(42);
    std::normal_distribution<> normal(0.0, 1.0);
    NumericVector V(n);
    for ( int i = 0; i < n; i++ ) {
        V[i] = normal(engine);
    }
    return V;
}
```
### 初期化リスト
{}を使った変数の初期化

```
int a[]  = {1,2,3};
vector<int> v = {1,2,3}
vector<string> vs  { "Hello", ", ", "World!", "\n" }; // = は無くてもOK

f({3.0});  //{3.0}はfの引数の型として解釈される
```

初期化リストを使うと暗黙の縮小変換が禁止される{}。()や単なる代入演算子だと暗黙の縮小変換をするが、初期化リストはエラーを返す。

```
int x(7.5); //x==7となる
int y=7.5; //y==7となる

int z = {7.5}; //エラー
int w {7.5}; //エラー
```

###auto
：自動的な型定義

変数の型を、代入する値に合わせてくれる。

```
auto i = 4; //iはint
auto const d=7.0; //dはconst     double;
vector<int> v;
auto it=v.begin(); //itはvector<int>::iterator
```


### 範囲for：いわゆるfor_each

```
vector<int> v = {1,2,3};  //ベクタの初期化
int total=0;
for(auto i : v) {
  total += i;
}
```

### 非メンバー begin(), end()

配列のようにSTLスタイルの.begin()や.end()メンバ関数を持っていないコンテナに対しても、最初と最後の要素のイテレータを指定できる。

```
vector<int> v;
auto i = begin(v); // v.begin()と同等


int a[100];
sort(begin(a),end(a));
```

### decltype：既存の変数や式の型と同じ型の変数

既にある、変数や式と同じ型の変数を作成できる。

```
int i;
decltype(i) x; //xはint
```

### クラス定義内でメンバ変数のデフォルト値の設定ができる

コンストラクタ内でなく、メンバ変数定義部で初期値を指定できる。コンストラクタ内で値を代入した場合には上書きされる。
class hoge{
    int x=1;
    ...
}

### ラムダ式：関数オブジェクトを簡単に定義できる

ラムダ関数は[]()->返型{}の書式をもつ。()には与える引数の他に、[]から自分自身が定義されたスコープ内のローカル変数にもアクセスできる。{}内に処理を記述。

[]内にはアクセスしたいローカルスコープ内の変数のリストを記述する。
[]はローカル変数にはアクセスしない
[&]は全てのローカル変数に参照アクセス
[=]は全てのローカル変数の値にアクセス
[&sum]や[=sum]なら変数sumのみにアクセス可能。

()はこのラムダ関数に渡される引数のリスト

->返型の部分は省略できる、すると、{}でリターンされた値の型が返される。

```
{//スコープここから
   vector<int> v = {1,2,3};
   int sum=0;
   int hoge=0;

   auto x = [](int i){cout << i << endl;} //関数オブジェクトxを作成
   for_each(begin(v),end(v), x());       //iにはvの要素が順々に渡される

   for_each(begin(v),end(v), [](int i){cout << i << endl;} );
   for_each(begin(v),end(v), [&sum](int i){sum+=i;} );       //sumのみアクセス可能
   for_each(begin(v),end(v), [&](int i){sum+=(i+hoge);} ); //sumとhogeにアクセスできる
}//スコープここまで
```

### 移動代入：値をコピーするのではなく直接移動させる

vectorやstringなど大きいデータはコピーするコストも馬鹿にならない。ただ値を別の変数に移動させたいだけなら、変数Aから変数Bに値をコピーするのではなくデータを直接移動させることができる（変数Aの値はその後使わない）。
全てのコンテナが移動代入と移動コンストラクタをサポートしている。また、関数から大きなデータを値で返すときに、コピーではなく移動させる様になった。

```
vector<int> v(1000,0); //0が1000個

//コピー代入：v2に値がコピーされ、vの値はそのまま残る
vector<int> v2 = v;

//移動代入：v3に値が移動し、vの値は消滅する
vector<int> v3 = move(v); 

v={1,2,3}; //vに値を再度代入するのはOK

//関数の返り値を受け取る時
vector<int> make_bigvector(){
    vector<int> x(1000,0);
    ...
    return x;//このxは右辺値（一時的にメモリに確保される値）として返される
}
vector<int> v = make_bigvector();  //関数の返値で初期化されるvにはxの値が移動される
```

一般に右辺値（一時的にメモリに確保される値）を受け取るときには移動代入される？move(x)はxを右辺値として渡す役割。


### 移動代入を用いたpush_back()

コピー代入版push_backよりもかなり効率が良いらしい。

```
//移動代入
vector<pair<string,int>> vp;
 string s; int i;
 while(cin>>s>>i) vp.push_back({s,i});
※sとiを用いてpair<string,int>の一時オブジェクト（右辺値）を生成しながら、ベクタに移動代入している。

//コピー代入
pair<string,int> var = {s,i};
vp.push_back(var);
```
同じ目的の異なるアプローチ：emplace_back()

ベクタの領域を拡張してそこに値を構築する。

```
vector<pair<string,int>> vp;
 string s; int i;
 while(cin>>s>>i) vp.emplace_back(s,i);

vp.push_back({s,i}); か vp.emplace_back(s,i);どちらが効率的かは実装に依存する。
```

### array：固定長配列コンテナ

```
//int型の要素数6の配列
array<int,6> a = { 1, 2, 3 }; //値は{1,2,3,0,0,0}となる
int* p = a; // エラー: std::array は暗黙的にポインタへ変換されない
int* p  = a.data(); //最初の要素へのポインタ
int* p1  = a.begin(); //同じくbegin(a) も行けた
array<int,6>::iterator i  = a.begin(); //イテレータ
```

### ハッシュテーブル：より効率のいいmap, set

map,multimap,set,multisetでは値がソートされているが、
C++11で追加された。
unordered_map
unordered_multimap
unordered_set
unordered_multiset
は値が追加された順に並んでおりソートされていない。要素の参照・検索や追加の効率が良い。
値がソートされている必要がないならハッシュテーブルの方がよさそう。

tuple：pair<T1,T2> → tuple<T1,T2,T3,...,Tn> 

３つ以上の値を一組にしたデータ。getで各値にアクセスする。

tuple<string,int,double> t={"hoge", 1, 2.0};
auto t2 = make_tuple(string("Herring"),10, 1.23);

string s = get<0>(t); //"hoge"
int i = get<1>(t); //1
double d = get<2>(t); //2.0

function：関数や関数オブジェクトを代入できる

int my_function(double, int);

function<int (double, int)> f = my_function ;
f(5.0, 1);
my_function(5.0, 1);
//これらは同等

bind：関数や関数オブジェクトの引数の値や順序を改変した関数オブジェクトを作成する






Smart pointer：後で勉強

unique_pointer
shared_ptr
weak_ptr


nullptr：ポインターの空初期化

int* p = nullptr;



ガーベージコレクション



乱数生成器

正規表現


スレッド