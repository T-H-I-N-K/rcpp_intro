# C++11

C++11 is a version of C++ standard approved by ISO in 2011. C++11 introduced so many new features, and some of which facilitate writing C++ code. In this document, we actively use following C++11 features.

**【IMPORTANT】C++11 must be enabled in most of sample codes in this document.**

## Enabling C++11

You can enable C++11 by adding following sentence somewhere in your Rcpp code.

```cpp
// [[Rcpp::plugins("cpp11")]]
```

## Selected features of C++11


### Initializer list

Initializing a vector with `{}`.

```
// Initializing vectors
NumericVector v1 = NumericVector::create(1.0, 2.0, 3.0); //construct and assign
NumericVector v2 = {1.0, 2.0, 3.0};     // Using initializer list
NumericVector v3   {1.0, 2.0, 3.0};     // You can omit =.
```

### auto

Declaration of a variable with `auto` specifier automatically decude data type of the variable from its initializer.

```
NumericVector v {1,2,3};

// The type of variable "it" will be deduced as NumericVector::iterator.
auto it = v.begin();
```

### Range-based for

"Range-based for" enables R style for-loop in C++.

```
IntegerVector v{1,2,3};
int sum=0;
for(auto x : v) { // The elements of v is sequencially copied to x
  sum += x;
}
```


### Lambda expression

you can easily construct unnameed function object by using Lambda expression.

The form of lambda expression is `[](){}`.

* `[]` : the list of local variables you want to access from this function object.
    * `[=x, &y]` : enabling access to local variable `x` and `y`. The `=x` indicate that the value is copied from local the variable `x`, and `&y` indicate that you can access directly to the local variable `y`.
    * `[=]` : enable access to the copied values of all the local variables.
    * `[&]` : enable direct access to all the local variables.
    * `[]`  : not accessing to the local variables.
* `()` : list of argment variables like as normal function.
* `{}` : the body the function object like as normal function..

The return type of a lambda exression is deduced from its return value by default, you can also explicitly specify the return type as follows.

```
// return type is int
[]()->int{}
```

Following example showed that, a lambda expression can be passed to apply function in the way similar to R.


``` R
# R code
v <- c(1,2,3,4,5)
A <- 2.0
res <-
  sapply(v, function(x){A*x})
```

``` cpp
// Rcpp code
NumericVector v = {1,2,3,4,5};
double A = 2.0;
NumericVector res =
    sapply(v, [&](double x){return A*x;});
```
